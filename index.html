<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Techné Bureau — Creative Technology & Brand Studio</title>
  <meta name="description" content="Techné Bureau — Creative technology and brand studio. Working with artists, galleries, and creative agencies. Currently by referral." />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@100;400&display=swap" rel="stylesheet">
  <style>
    html,body{
      height:100%;
      margin:0;
      background:#05070a;
      overflow:hidden;
    }
    canvas{ position:fixed; inset:0; width:100%; height:100%; display:block; }
  </style>
</head>

<body>
<canvas id="c" aria-hidden="true"></canvas>

<script>
  /**
   @author ertdfgcvb
   @title  Time: milliseconds
   @desc   Use of context.time
   */

    // Your pattern
  const pattern = 'abcdefghxyz·:;=~-+÷øæ. ';

  // Fixed center text (does not change)
  const LINES = [
    'Techné Bureau',
    '',
    'Creative technology and brand studio.',
    'Working with artists, galleries,',
    'and creative agencies.',
    '',
    'Currently by referral.',
  ];

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let fontSize = 14;
  let cellW = 10, cellH = 18;
  let cols = 0, rows = 0;

  function resize(){
    fontSize = innerWidth < 600 ? 12 : 14;

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.textBaseline = 'top';
    ctx.font = `100 ${fontSize}px "IBM Plex Mono", monospace`;

    cellW = Math.ceil(ctx.measureText('M').width);
    cellH = Math.ceil(fontSize * 1.22);

    cols = Math.ceil(innerWidth / cellW);
    rows = Math.ceil(innerHeight / cellH);
  }
  window.addEventListener('resize', resize);
  resize();

  // Your main loop logic
  function main(coord, context) {
    const t = context.time * 0.0001;
    const x = coord.x;
    const y = coord.y;
    const o = Math.sin(y * Math.sin(t) * 0.2 + x * 0.04 + t) * 20;
    const i = Math.round(Math.abs(x + y + o)) % pattern.length;
    return { char: pattern[i], fontWeight: '100' };
  }

  // Helpers: map pixel center -> grid coordinates
  function pxToGridX(px){ return Math.floor(px / cellW); }
  function pxToGridY(py){ return Math.floor(py / cellH); }

  function render(now){
    const context = { time: now };

    // Background
    ctx.clearRect(0, 0, innerWidth, innerHeight);
    ctx.fillStyle = '#05070a';
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    // Set “scene” text style
    ctx.font = `100 ${fontSize}px "IBM Plex Mono", monospace`;
    ctx.fillStyle = 'rgba(233,238,246,.72)';

    // Build a "protected" region (in grid units) anchored bottom-left with 24px margin
    const marginCols = Math.ceil(24 / cellW);
    const marginRows = Math.ceil(24 / cellH);

    // Compute the box size around all lines
    const maxLen = Math.max(...LINES.map(l => l.length));
    const boxW = maxLen + 8; // padding in characters
    const boxH = LINES.length + 2; // top/bottom padding + lines

    const boxLeft = marginCols;
    const boxTop  = rows - boxH - marginRows;

    const boxRight = boxLeft + boxW - 1;
    const boxBottom = boxTop + boxH - 1;

    // Draw the animated field, but “mask” the box area so it stays clean
    for (let gy = 0; gy < rows; gy++) {
      for (let gx = 0; gx < cols; gx++) {

        // Skip inside the center box (so text is readable)
        if (gx >= boxLeft && gx <= boxRight && gy >= boxTop && gy <= boxBottom) {
          continue;
        }

        const res = main({ x: gx, y: gy, index: gy * cols + gx }, context);
        ctx.fillText(res.char, gx * cellW, gy * cellH);
      }
    }

    // Optional: draw a subtle ASCII frame using pattern characters (still “part of script”)
    // You can remove this block if you want no frame at all.

    // Draw fixed center text (does not change)
    ctx.fillStyle = 'rgba(233,238,246,.92)';

    for (let ln = 0; ln < LINES.length; ln++) {
      const line = LINES[ln];
      const lx = boxLeft + 4; // left-aligned with padding
      const ly = boxTop + 1 + ln;
      for (let i = 0; i < line.length; i++) {
        ctx.fillText(line[i], (lx + i) * cellW, ly * cellH);
      }
    }

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
</script>
</body>
</html>
